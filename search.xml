<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WiFi、NFC和蓝牙相关调研测试]]></title>
    <url>%2F2019%2F10%2F24%2FWiFi%E3%80%81NFC%E5%92%8CBluetooth%E7%9B%B8%E5%85%B3%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[概述此文档涉及部分如下： WiFi WIFI是否开启 搜索周边热点信息，并按照信号强弱排序 获取正在连接中wifi的信息 NFC demo 判断设备是否支持 NFC 或 设备的 NFC 是否打开 启用NFC感应/禁用NFC感应 接收到感应消息并对消息解码 向 NFC 中写入数据 蓝牙 demo 蓝牙是否开启或设备是否支持 查询本地蓝牙适配器已配对的蓝牙设备 扫描周围的其他蓝牙设备 WiFi能获取到哪些信息WifiManagerwifi连接统一管理类，获取WIFI网卡的状态(WIFI网卡的状态是由一系列的整形常量来表示的) 状态 注释 WIFI_STATE_DISABLING = 0 WIFI网卡正在关闭 WIFI_STATE_DISABLED = 1 WIFI网卡不可用 WIFI_STATE_ENABLING = 2 WIFI网卡正在打开 WIFI_STATE_ENABLED = 3 WIFI网卡可用 WIFI_STATE_UNKNOWN = 4 未知网卡状态 WifiInfo 方法名 注释 getSSID() 获得SSID（热点名称） getBSSID() 获取BSSID getDetailedStateOf() 获取客户端的连通性 getHiddenSSID() 获得SSID 是否被隐藏 getIpAddress() 获取IP 地址 getLinkSpeed() 获得连接的速度 getMacAddress() 获得Mac 地址 如何使用在AndroidManifest.xml添加权限设置1234567&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; 使用方法WIFI是否开启12345private boolean isOpen() &#123; mWifiManager = (WifiManager) mContext.getApplicationContext().getSystemService(Context.WIFI_SERVICE); mConnectivityManager = (ConnectivityManager) this.getApplicationContext().getSystemService(Context.CONNECTIVITY_SERVICE); return mWifiManager != null &amp;&amp; mWifiManager.isWifiEnabled();&#125; 搜索周边热点信息，并按照信号强弱排序搜索周边热点信息1234567891011121314151617181920private String ScanWifiInfo() &#123; // 扫描热点,扫描时耗时操作，如果界面中需要展示进度条的话，建议将扫描操作放在子线程中操作 boolean isSuccess = mWifiManager.startScan(); // 得到扫描结果 List&lt;ScanResult&gt; mWifiList = mWifiManager.getScanResults(); // 得到配置好的网络连接,列表中可能出现重复的热点，并且可能是ssid为空的热点，根据需求情况 自行过滤 mWifiConfiguration = mWifiManager.getConfiguredNetworks(); mWifiList = sortByLevel(mWifiList); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; mWifiList.size(); i++) &#123; stringBuilder.append(&quot;Index_&quot;).append(Integer.valueOf(i + 1).toString()).append(&quot;:&quot;); // 将ScanResult信息转换成一个字符串包 // 其中把包括：BSSID、SSID、capabilities、frequency、level stringBuilder.append((mWifiList.get(i)).toString()).append(&quot;信号强度：&quot;).append(mWifiList.get(i).level); stringBuilder.append(&quot;\n&quot;); &#125; return stringBuilder.toString();&#125; 按照信号强弱排序1234567891011121314151617181920/** * 将搜索到的wifi根据信号从强到弱进行排序 * * @param list * @return */private List&lt;ScanResult&gt; sortByLevel(List&lt;ScanResult&gt; list) &#123; ScanResult temp = null; for (int i = 0; i &lt; list.size(); i++) &#123; for (int j = 0; j &lt; list.size(); j++) &#123; //level属性即为强度 if (list.get(i).level &gt; list.get(j).level) &#123; temp = list.get(i); list.set(i, list.get(j)); list.set(j, temp); &#125; &#125; &#125; return list;&#125; 获取正在连接中wifi的信息1234567891011121314151617private String getWifiInfo() &#123; WifiInfo mWifiInfo = mWifiManager.getConnectionInfo(); NetworkInfo wifiInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI); String wifiName = wifiInfo.getExtraInfo(); StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(&quot;BSSID：&quot;).append(mWifiInfo.getBSSID()).append(&quot;\n&quot;) .append(&quot;SSID：&quot;).append(mWifiInfo.getSSID()).append(&quot;\n&quot;) .append(&quot;IpAddress：&quot;).append(mWifiInfo.getIpAddress()).append(&quot;\n&quot;) .append(&quot;MacAddress：&quot;).append(mWifiInfo.getMacAddress()).append(&quot;\n&quot;) .append(&quot;LinkSpeed：&quot;).append(mWifiInfo.getLinkSpeed()).append(&quot;\n&quot;) .append(&quot;HiddenSSID：&quot;).append(mWifiInfo.getHiddenSSID()).append(&quot;\n&quot;) .append(&quot;wifiName：&quot;).append(wifiName).append(&quot;\n&quot;); return String.valueOf(stringBuilder);&#125; 注：API level 29已将大部分方法废弃，建议将 compileSdkVersion 和 targetSdkVersion 设置为 26(在 Android 9 的手机上不影响正常使用且不影响 APP 上架)。例如：将 WiFiManager 的 startScan() 方法标为了废弃，前台应用 2 分钟内只能使用 4 次startScan()，后台应用 30 分钟内只能调用 1次 startScan()，否则会直接返回 false 并且不会触发扫描操作。 NFC基础概念NFC的全称是“Near Field Communication”，意思是近场通信、与邻近的区域通信。大众所熟知的NFC技术应用，主要是智能手机的刷卡支付功能。 带有NFC功能的手机，在实际生活中主要有三项应用：读卡、写卡、分享内容（两部手机之间传输数据）。 如何使用在AndroidManifest.xml添加权限设置12345&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.NFC&quot; /&gt;&lt;uses-feature android:name=&quot;android.hardware.nfc&quot; android:required=&quot;true&quot; /&gt; 对活动页面声明NFC过滤器目前Android支持NDEF_DISCOVERED、TAG_DISCOVERED、TECH_DISCOVERED这三种过滤器，最好把它们都加入到过滤器列表中，示例如下： 12345678910111213141516&lt;activity android:name=&quot;.NFCActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.NDEF_DISCOVERED&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.TAG_DISCOVERED&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.nfc.action.TECH_DISCOVERED&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.nfc.action.TECH_DISCOVERED&quot; android:resource=&quot;@xml/nfc_tech_filter&quot; /&gt;&lt;/activity&gt; 其中TECH_DISCOVERED类型另外指定了过滤器的来源是@xml/nfc_tech_filter，该文件的实际路径为xml/nfc_tech_filter.xml，文件内容如下所示： 1234567891011121314&lt;resources&gt; &lt;!-- 可以处理所有Android支持的NFC类型 --&gt; &lt;tech-list&gt; &lt;tech&gt;android.nfc.tech.NfcA&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NfcB&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NfcF&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NfcV&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.IsoDep&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.Ndef&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.NdefFormatable&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.MifareClassic&lt;/tech&gt; &lt;tech&gt;android.nfc.tech.MifareUltralight&lt;/tech&gt; &lt;/tech-list&gt;&lt;/resources&gt; 解释：NFC类型虽多，常见的NfcA、NfcB、IsoDep三个系出ISO14443标准（即RFID卡标准）1.NfcA遵循ISO14443-3A标准，常用于门禁卡；2.NfcB遵循ISO14443-3B标准，常用于二代身份证；3.IsoDep遵循ISO14443-4标准，常用于公交卡； 判断设备是否支持 NFC 或 设备的 NFC 是否打开12345678private boolean isSupportNFC() &#123; mNfcAdapter = NfcAdapter.getDefaultAdapter(mContext); if (mNfcAdapter == null) &#123; return false; &#125; else &#123; return mNfcAdapter.isEnabled(); &#125;&#125; 若 mNfcAdapter 为 null，则该设备不支持 NFC，若 mNfcAdapter.isEnabled() 为 false，则该设备未打开 NFC 设置。 初始化 NFC1234567891011121314151617181920private void initNFC() &#123; // 探测到NFC卡片后，必须以FLAG_ACTIVITY_SINGLE_TOP方式启动Activity， // 或者在AndroidManifest.xml中设置launchMode属性为singleTop或者singleTask， // 保证无论NFC标签靠近手机多少次，Activity实例都只有一个。 Intent intent = new Intent(this, NFCActivity.class) .addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); // 声明一个NFC卡片探测事件的相应动作 mPendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT); try &#123; // 定义一个过滤器（检测到NFC卡片） mFilters = new IntentFilter[]&#123;new IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED, &quot;*/*&quot;)&#125;; &#125; catch (Exception e) &#123; Log.d(TAG, &quot;initNFC: &quot; + e.getMessage()); e.printStackTrace(); &#125; // 读标签之前先确定标签类型 mTechLists = new String[][]&#123;new String[]&#123;NfcA.class.getName()&#125;, &#123;IsoDep.class.getName()&#125;&#125;; Log.d(TAG, &quot;initNFC: &quot;);&#125; 启用NFC感应/禁用NFC感应123456789101112131415@Overrideprotected void onResume() &#123; super.onResume(); if (isSupportNFC()) &#123; mNfcAdapter.enableForegroundDispatch(this, mPendingIntent, mFilters, mTechLists); &#125;&#125;@Overrideprotected void onPause() &#123; super.onPause(); if (isSupportNFC()) &#123; mNfcAdapter.disableForegroundDispatch(this); &#125;&#125; 接收到感应消息并对消息解码通过前一步启用NFC感应之后，一旦App接收到感应消息，就会回调 Activity 的 onNewIntent 函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Overrideprotected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); String card_info = &quot;&quot;; // 获取到本次启动的action String action = intent.getAction(); if (action.equals(NfcAdapter.ACTION_NDEF_DISCOVERED) // NDEF类型 || action.equals(NfcAdapter.ACTION_TECH_DISCOVERED) // 其他类型 || action.equals(NfcAdapter.ACTION_TAG_DISCOVERED)) &#123; // 未知类型 // 从intent中读取NFC卡片内容 Tag tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG); // 获取NFC卡片的序列号 byte[] ids = tag.getId(); card_info = String.format(&quot;卡片的序列号为: %s&quot;, getHex(ids)); setResult(card_info + &quot;\n&quot; + readNFCCard(tag)); &#125; else &#123; Log.d(TAG, &quot;onNewIntent: 未识别&quot;); setResult(&quot;未识别&quot;); &#125;&#125;public String readNFCCard(Tag tag) &#123; MifareClassic classic = MifareClassic.get(tag); String info; try &#123; classic.connect(); // 连接卡片数据 int type = classic.getType(); //获取TAG的类型 String typeDesc; if (type == MifareClassic.TYPE_CLASSIC) &#123; typeDesc = &quot;传统类型&quot;; &#125; else if (type == MifareClassic.TYPE_PLUS) &#123; typeDesc = &quot;增强类型&quot;; &#125; else if (type == MifareClassic.TYPE_PRO) &#123; typeDesc = &quot;专业类型&quot;; &#125; else &#123; typeDesc = &quot;未知类型&quot;; &#125; info = String.format(&quot;\t卡片类型：%s\n\t扇区数量：%d\n\t分块个数：%d\n\t存储空间：%d字节&quot;, typeDesc, classic.getSectorCount(), classic.getBlockCount(), classic.getSize()); &#125; catch (Exception e) &#123; e.printStackTrace(); info = e.getMessage(); &#125; finally &#123; // 无论是否发生异常，都要释放资源 try &#123; classic.close(); // 释放卡片数据 &#125; catch (Exception e) &#123; e.printStackTrace(); info = e.getMessage(); &#125; &#125; return info;&#125; 解释：MifareClassic 类的方法说明：get : 从Tag对象中获取卡片对象的信息。connect : 连接卡片数据。close : 释放卡片数据。getType : 获取卡片的类型。TYPE_CLASSIC表示传统类型，TYPE_PLUS表示增强类型，TYPE_PRO表示专业类型。getSectorCount : 获取卡片的扇区数量。getBlockCount : 获取卡片的分块个数。getSize : 获取卡片的存储空间大小，单位字节 此时可以使用校园卡等部分卡，进行测试了。 向 NFC 中写入数据12345678910111213141516171819202122232425262728293031323334private String mNfcTagName = &quot;com.android.mms&quot;;public void writeNFCTag(Tag tag) &#123; if (tag == null) &#123; return; &#125; final NdefMessage ndefMessage = new NdefMessage(new NdefRecord[]&#123;NdefRecord.createApplicationRecord(mNfcTagName)&#125;); int size = ndefMessage.toByteArray().length; try &#123; Ndef ndef = Ndef.get(tag); if (ndef != null) &#123; ndef.connect(); if (!ndef.isWritable()) &#123; return; &#125; if (ndef.getMaxSize() &lt; size) &#123; return; &#125; ndef.writeNdefMessage(ndefMessage); toast(&quot;写入数据成功&quot;); &#125; else &#123; final NdefFormatable format = NdefFormatable.get(tag); if (format != null) &#123; format.connect(); format.format(ndefMessage); &#125; else &#123; toast(&quot;写入数据失败&quot;); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); toast(&quot;Exception:&quot; + e.getMessage()); &#125;&#125; 注：自测下来，目前市面上的大部分卡(校园卡，地铁卡等)无法写入数据。 蓝牙概览Android 应用可通过 Bluetooth API 执行以下操作： 扫描其他蓝牙设备 查询本地蓝牙适配器的配对蓝牙设备 建立 RFCOMM 通道 通过服务发现连接到其他设备 与其他设备进行双向数据传输 管理多个连接 本文介绍蓝牙配置文件，还将介绍如何使用 Android Bluetooth API 来完成扫描其他设备、查询本地蓝牙适配器的配对蓝牙设备，以及通过服务发现连接到其他设备等。 如何使用在AndroidManifest.xml添加权限设置123&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt; 蓝牙是否开启或设备是否支持12345678private boolean isSupportBluetooth() &#123; mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); if (mBluetoothAdapter == null) &#123; return false; &#125; else &#123; return mBluetoothAdapter.isEnabled(); &#125;&#125; 若 mBluetoothAdapter 为 null，则该设备不支持 蓝牙，若 mBluetoothAdapter.isEnabled() 为 false，则该设备未打开 NFC 设置。 查询本地蓝牙适配器已配对的蓝牙设备123456789101112131415161718/** * 查询本地蓝牙适配器已配对的蓝牙设备 * * @return */private String getPairedBtDevices() &#123; StringBuilder stringBuilder = new StringBuilder(); Set&lt;BluetoothDevice&gt; pairedDevices = mBluetoothAdapter.getBondedDevices(); if (pairedDevices.size() &gt; 0) &#123; for (BluetoothDevice device : pairedDevices) &#123; // 把名字和地址取出来 stringBuilder.append(&quot;\t设备名：&quot;).append(device.getName()).append(&quot;\n\tAddress：&quot;).append(device.getAddress()).append(&quot;\n&quot;); &#125; return stringBuilder.toString(); &#125; else &#123; return null; &#125;&#125; 扫描周围的其他蓝牙设备启动扫描： 123if (mBluetoothAdapter.startDiscovery()) &#123; setResult(&quot;启动蓝牙，扫描设备中...&quot;);&#125; 为了得到扫描结果，需要在一个广播接收器中异步接收 Android 系统发送的扫描结果： 1234567891011121314// 广播接收发现蓝牙设备private final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (BluetoothDevice.ACTION_FOUND.equals(action)) &#123; BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); // 把名字和地址取出来 mArrayAdapter.add(&quot;\t设备名：&quot; + device.getName() + &quot;\n\tAddress：&quot; + device.getAddress()); mArrayAdapter.notifyDataSetChanged(); &#125; &#125;&#125;; 项目地址请戳我]]></content>
      <categories>
        <category>Android</category>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>WiFi</tag>
        <tag>NFC</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dialog 区域外可响应点击事件]]></title>
    <url>%2F2019%2F09%2F26%2FDialog-%E5%8C%BA%E5%9F%9F%E5%A4%96%E5%8F%AF%E5%93%8D%E5%BA%94%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[问题如下图，理想状态：点击左边的 Button1 左边的 fragment 展示页面一，点击 Button5，fragment 展示页面五，并弹出 dialog5，点击 Button6，dialog5 消失，并且 fragment 展示页面六，并弹出 dialog6。 实际状态：点击 Button5，fragment 展示页面五，并弹出 dialog5，然后第一次点击 Button6，dialog5 消失，再一次点击 Button6，fragment 展示页面六，并弹出 dialog6。 问题简化：Activity 未能接收Dialog区域外的点击事件。 解决方案 在Dialog的构造函数中添加以下两行代码，设置Window的标志位，就可以让Activity响应Dialog区域外的点击事件； 123456789//实现Dialog区域外部事件可以传给Activity //FLAG_NOT_TOUCH_MODAL作用：即使该window可获得焦点情况下，仍把该window之外的任何event发送到该window之后的其他windowgetWindow().setFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL, WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL); //FLAG_WATCH_OUTSIDE_TOUCH作用：如果点击事件发生在window之外，就会收到一个特殊的MotionEvent，为ACTION_OUTSIDEgetWindow().setFlags(WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH, WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH); 再重写Dialog中的onTouch事件，点击Dialog区域外时，把Dialog隐藏掉即可。 123456789getWindow().getDecorView().setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; if (event.getAction() == MotionEvent.ACTION_OUTSIDE) &#123; dismiss(); &#125; return true; &#125;&#125;);]]></content>
      <categories>
        <category>Android</category>
        <category>问题排查</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>dialog</tag>
        <tag>点击事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android版本更新]]></title>
    <url>%2F2019%2F09%2F20%2FAndroid-%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题1234567private void installApk(Context context, File file) &#123; Intent install = new Intent(); install.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); install.setAction(Intent.ACTION_VIEW); install.setDataAndType(Uri.fromFile(file), &quot;application/vnd.android.package-archive&quot;); context.getApplicationContext().startActivity(install);&#125; 下载新的apk后，安装apk时，大部分都用的这段代码。 这段代码在Android 7.0之前是没有问题的，但在7.0之后的手机上，可能会报一下的错： 1android.os.FileUriExposedException: file:///storage/emulated/0/a/test.apk exposed beyond app through Intent.getData() 解决方案方案一（不推荐）检查 targetSdkVersion ，并把他降到23(&lt;=23)。 如果应用百分百不打算上架的话，就这么改吧，多方便 [囧]。 方案二（推荐）官方文档：Android7.0行为变更 代码修改修改清单文件在 application节点下增加 provider 1234567891011121314151617&lt;manifest&gt; ... &lt;application&gt; ... &lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;$&#123;applicationId&#125;.fileprovider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/provider_paths&quot;/&gt; &lt;/provider&gt; &lt;/provider&gt; ... &lt;/application&gt;&lt;/manifest&gt; 在res文件夹下，新建xml文件夹，新建文件provider_paths 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths&gt; &lt;external-path name=&quot;external&quot; path=&quot;.&quot; /&gt; &lt;files-path name=&quot;files&quot; path=&quot;.&quot; /&gt; &lt;cache-path name=&quot;cache&quot; path=&quot;.&quot; /&gt; &lt;external-files-path name=&quot;external_file_path&quot; path=&quot;.&quot; /&gt; &lt;external-cache-path name=&quot;external_cache_path&quot; path=&quot;.&quot; /&gt;&lt;/paths&gt; 解释： external-path的路径对应的是 Environment.getExternalStorageDirectory()路径 cache-path:getCacheDir() files-path:Context.getFilesDir() external-files-path:Context#getExternalFilesDir(String) Context.getExternalFilesDir(null) external-cache-path:Context.getExternalCacheDir() external-media-path:Context.getExternalMediaDirs() path=”.”表示的是Environment.getExternalStorageDirectory()下的所有文件夹 如果想指定某一个文件夹,例如images：应该这样写 path=“images/” 修改安装apk的代码123456789101112131415private void installApk(Activity activity,File file) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.N) &#123; intent.setDataAndType(Uri.fromFile(file), &quot;application/vnd.android.package-archive&quot;); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); &#125; else &#123; // 声明需要的临时的权限 intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); // 第二个参数，容易导错包，清单文件和module要保持一致 Uri contentUri = FileProvider.getUriForFile(activity, activity.getPackageName() + &quot;.core.fileprovider&quot;, file); intent.setDataAndType(contentUri, &quot;application/vnd.android.package-archive&quot;); &#125; activity.startActivity(intent); &#125; over，测试一下，发现7.0的手机安装没问题了，但在 &gt;=8.0 上安装，还是有问题，只不过不是包之前的错了，而是app没有反应，一闪而过。 &gt;=8.0 安装不了的问题增加新权限1&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot;/&gt; 把 ACTION_VIEW 改为 ACTION_INSTALL_PACKAGE如下： 12345Intent intent = new Intent(Intent.ACTION_VIEW)//改为Intent intent = new Intent(Intent.ACTION_INSTALL_PACKAGE); 完整代码如下123456789101112131415private void installApk(Activity activity,File file) &#123; Intent intent = new Intent(Intent.ACTION_INSTALL_PACKAGE); if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.N) &#123; intent.setDataAndType(Uri.fromFile(file), &quot;application/vnd.android.package-archive&quot;); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); &#125; else &#123; // 声明需要的临时的权限 intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); // 第二个参数，容易导错包，清单文件和module要保持一致 Uri contentUri = FileProvider.getUriForFile(activity, activity.getPackageName() + &quot;.core.fileprovider&quot;, file); intent.setDataAndType(contentUri, &quot;application/vnd.android.package-archive&quot;); &#125; activity.startActivity(intent); &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>问题排查</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>文件获取</tag>
        <tag>版本更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS下安装Redis]]></title>
    <url>%2F2019%2F09%2F17%2FMacOS%E4%B8%8B%E5%AE%89%E8%A3%85Redis%2F</url>
    <content type="text"><![CDATA[下载Redis官网下载：https://redis.io/ 选择最新的版本，我现在下的是：http://download.redis.io/releases/redis-5.0.5.tar.gz 安装安装就几条命令，对于自己的版本做修改吧。 1234567891011121314# 解压tar -zxvf redis-5.0.5.tar.gz# 拷贝的local目录下sudo cp -rf redis-5.0.5 /usr/local/# 进入相应目录下cd /usr/local/redis-*# 编译sudo make test# 安装sudo make install# 建立相应目录sudo mkdir bin etc db# 拷贝启动文件sudo cp src/mkreleasehdr.sh src/redis-benchmark src/redis-check-rdb src/redis-cli src/redis-server bin/ 如果在编译时报错了，清理了再编译一下：sudo make distclean &amp;&amp; sudo make &amp;&amp; sudo make test 3.配置配置看注释吧。（没有硬性需求可以不做修改） 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 拷贝配置文件（在redis目录下）sudo cp redis.conf etc/sudo vi etc/redis.conf####内容参照如下：(选择性修改就好了，不用全都照着改)#修改为守护模式（后台启动）daemonize yes#设置进程锁文件pidfile /usr/local/redis-5.0.5/redis.pid#端口port 6379#客户端超时时间timeout 300#日志级别loglevel debug#日志文件位置logfile /usr/local/redis-5.0.5/log-redis.log#设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库iddatabases 16##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合#save &lt;seconds&gt; &lt;changes&gt;#Redis默认配置文件中提供了三个条件：save 900 1save 300 10save 60 10000#指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，#可以关闭该#选项，但会导致数据库文件变的巨大rdbcompression yes#指定本地数据库文件名dbfilename dump.rdb#指定本地数据库路径dir /usr/local/redis-5.0.5/db/#指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能#会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有#的数据会在一段时间内只存在于内存中appendonly no#指定更新日志条件，共有3个可选值：#no：表示等操作系统进行数据缓存同步到磁盘（快）#always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）#everysec：表示每秒同步一次（折衷，默认值）appendfsync everysec# 设置连接密码requirepass 123456 4.服务启动1sudo /usr/local/redis-5.0.5/src/redis-server /usr/local/redis-5.0.5/etc/redis.conf 如果觉得命令太长了，建议使用别名（alias）结束redis服务：（当然可以直接结束进程）在客户端执行 SHUTDOWN 或 SHUTDOWN NOSAVE 可关闭 redis 服务 5.客户端redis自带客户端工具，可以直接使用 123456# 进入相应目录cd /usr/local/redis-5.0.5/src/# 启动客户端连接sudo ./redis-cli # 如果有密码sudo ./redis-cli auth 123456 客户端基本命令： 命令 用途 keys * 查看所有的 key exists key 查看此 key 是否存在 get key 获取 key 的值 set key value 设置 key 的值 flushall 清空所有 这里推荐一个图形界面的redis工具Redis桌面管理工具Mac版：http://www.pc6.com/mac/486661.html]]></content>
      <categories>
        <category>软件安装</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>配置</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android热修复-Robust]]></title>
    <url>%2F2019%2F09%2F17%2FAndroid%E7%83%AD%E4%BF%AE%E5%A4%8D-Robust%2F</url>
    <content type="text"><![CDATA[什么是热修复热修复（也称热补丁、热修复补丁，英语：hotfix）是一种包含信息的独立的累积更新包，通常表现为一个或多个文件。这被用来解决软件产品的问题（例如一个程序错误）。通常情况下，热修复是为解决特定用户的具体问题而制作。 正常开发流程 热修复开发流程 热修复优势 修复什么 热修复框架的对比按公司团队划分： 类别 成果 阿里系 AndFix、Dexposed、阿里百川HotFix(未开源)、Sophix(未开源) 腾讯系 微信的Tinker、QQ空间的超级补丁(未开源)、手机QQ的QFix 知名公司 美团的Robust、饿了么的Amigo、美丽说蘑菇街的Aceso 其他 百度金融的RocooFix、大众点评的Nuwa、AnoleFix 可见，热修复框架很多，但核心技术只有三类：代码修复、资源修复和动态链接库修复，其中每个核心技术又有很多不同的技术方案，每个技术方案又有不同的实现，另外这些热修复框架仍在不断的更新迭代中，由此可见，热修复框架的技术实现是繁多可变的。 比较出名的修复框架的对比如下： 特性 AndFix Tinker QQ空间 Robust 即时生效 是 否 否 是 方法替换 是 是 是 是 类替换 否 是 是 否 类结构修改 否 是 否 否 资源替换 否 是 是 否 so替换 否 是 否 否 支持gradle 否 是 否 否 支持ART 是 是 是 是 性能损耗 较小 较小 较小 较小 补丁包大小 一般 较小 较大 一般 复杂度 复杂 较低 较低 复杂 成功率 一般 较高 较高 最高 支持 Android 版本 2.3-7.0 2.x－8.x 2.x－7.x 2.3-9.x 从上表中，我们可以发现每个热修复框架各有优缺点，其中美团的Robust支持的 Android 版本可达到9.x，且支持方法级别的修复，包括静态方法，也支持增加方法和类，所以此次着重讲解美团的Robust的部分原理和使用。 美团Robust – Instant Run 热插拔原理原理 Robust插件对每个产品代码的每个函数都在编译打包阶段自动的插入了一段代码，插入过程对业务开发是完全透明 编译打包阶段自动为每个class都增加了一个类型为ChangeQuickRedirect的静态成员，而在每个方法前都插入了使用changeQuickRedirect相关的逻辑，当 changeQuickRedirect不为null时，可能会执行到accessDispatch从而替换掉之前老的逻辑，达到fix的目的。 优点 支持Android2.3-9.x版本 高兼容性、高稳定性，修复成功率高达99.9% 补丁实时生效，不需要重新启动 支持方法级别的修复，包括静态方法 支持增加方法和类 支持ProGuard的混淆、内联、优化等操作 缺点 代码是侵入式的，会在原有的类中加入相关代码 会增大apk的体积，平均一个函数会比原来增加17.47个字节，10万个函数会增加1.67M 会增加少量方法数 实战新建项目并导入相应的包 在 App 的 build.gradle，加入如下依赖 123456apply plugin: &apos;com.android.application&apos;//制作补丁时将这个打开，auto-patch-plugin紧跟着com.android.application//apply plugin: &apos;auto-patch-plugin&apos;apply plugin: &apos;robust&apos; compile &apos;com.meituan.robust:robust:0.4.90&apos; 在整个项目的build.gradle加入classpath 123456789buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.meituan.robust:gradle-plugin:0.4.90&apos; classpath &apos;com.meituan.robust:auto-patch-plugin:0.4.90&apos; &#125;&#125; 注：要开启资源压缩，开启混淆，后面需要 mapping.txt 文件。 开启资源压缩，开启混淆 12345678910111213buildTypes &#123; release &#123; shrinkResources true minifyEnabled true proguardFiles getDefaultProguardFile(&apos;proguard-android-optimize.txt&apos;), &apos;proguard-rules.pro&apos; &#125; //为方便调试，debug也开启 debug &#123; shrinkResources true minifyEnabled true proguardFiles getDefaultProguardFile(&apos;proguard-android-optimize.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125; 创建相应文件夹及 robust.xml 文件最终文件大概图： robust 文件夹：存放 methodsMap.robust[build/outputs/robust/methodsMap.robust] 和 mapping.txt[build/outputs/mapping/mapping.txt] 文件； robust.xml 文件：一些配置信息，一般直接从官方网站上 copy 一份即可。 如何生成补丁 将打出的正式包的 methodsMap.robust 和 mapping.txt 文件存放到 robust 文件夹中，如下： 将 App 的 build.gradle 中 auto-patch-plugin 注释打开，如下： 1234apply plugin: &apos;com.android.application&apos;//制作补丁时将这个打开，auto-patch-plugin紧跟着com.android.applicationapply plugin: &apos;auto-patch-plugin&apos;//apply plugin: &apos;robust&apos; 修改需要修改或增加的文件，添加相关注释(@Modify / @Add)； 像正常打包一样打包，会出现如下提示： 生成的补丁包在 app/build/outputs/robust/patch.jar 位置，如下： 注：生成正式包与补丁，都需要秘钥。 补丁包的引入 可手动复制进相应的目录； 可通过 adb 导入相应的目录； 可下载补丁包至指定的目录。 目前笔者采用的是下载补丁包至指定目录，放置位置可自由设定，笔者设置的目录为：/storage/emulated/0/robust/patch/ 注意点 需要开启资源压缩，开启混淆； 打正式包或补丁，需要秘钥； 打补丁需要之前打正式包的 methodsMap.robust 和 mapping.txt 文件； robust.xml 中需要在 hotfixPackage 中设置自己的包名； 调试的时候，debug需要开启资源压缩和混淆。 项目地址请戳这里]]></content>
      <categories>
        <category>Android</category>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>热修复</tag>
        <tag>Robust</tag>
        <tag>美团</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android进程保活]]></title>
    <url>%2F2019%2F08%2F28%2FAndroid-%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[前言很多项目都希望我们的 APP 可以一直在用户的后台运行，也就是所谓的 Android 进程保活。本文档主要讲解目前测试下来有效的 Android 保活方案。 注：随着 Android 的版本越来越高，APP 在后台的存活时间也就越来越短，目前所做的是让 APP 在后台存活时间尽量延长。 前期准备 安装 Android studio，并配好相应的环境； 准备一首没有声音的mp3音频，请自行百度下载； 准备一台或多台安卓设备进行测试。 开发流程四种大概方案方案一：播放无声的音乐 将之前准备的 mp3 音频放置到 res/raw 文件下，如下图： 新建一个播放音乐的Service类，将播放模式改为无限循环播放： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MusicService extends Service &#123; private String TAG = MusicService.class.getSimpleName(); private MediaPlayer mMediaPlayer; public MusicService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, &quot;onCreate: 启动服务&quot;); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; mMediaPlayer = MediaPlayer.create(getApplicationContext(), R.raw.music); mMediaPlayer.setLooping(true); playMusic(); return START_STICKY; &#125; private void playMusic() &#123; if (mMediaPlayer != null &amp;&amp; !mMediaPlayer.isPlaying()) &#123; Log.d(TAG, &quot;playMusic: 启动后台播放音乐&quot;); mMediaPlayer.start(); &#125; &#125; private void stopMusic() &#123; if (mMediaPlayer != null) &#123; Log.d(TAG, &quot;stopMusic: 关闭后台播放音乐&quot;); mMediaPlayer.stop(); &#125; &#125; @Override public void onDestroy() &#123; super.onDestroy(); stopMusic(); Log.d(TAG, &quot;onDestroy: 停止服务&quot;); &#125;&#125; 在需要保活的 service 中加上此方式或在 onCreate 方法中对 MusicService 进行启动： 1startService(new Intent(this, MusicService.class)); 在 Manifest 文件中进行注册 1234&lt;service android:name=&quot;.service.MusicService&quot; android:priority=&quot;1000&quot; ndroid:persistent=&quot;true&quot; /&gt; 方案二：双service+常驻通知栏 创建 CoreService ,负责定时检测主要的 service 是否存活，若不存活，则拉活该 service： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class CoreService extends Service &#123; private ScheduledThreadPoolExecutor mScheduled; public CoreService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; if (mScheduled == null) &#123; mScheduled = new ScheduledThreadPoolExecutor(1); mScheduled.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; if (!isServiceRunning(getApplicationContext(),&quot;com.dyw.keepalive.service.MusicService&quot;))&#123; Log.d(TAG, &quot;run: 启动 GpsService&quot;); startService(new Intent(getApplicationContext(),MusicService.class)); &#125; &#125; &#125;, 0, 500, TimeUnit.MILLISECONDS); &#125; return START_STICKY; &#125; public static boolean isServiceRunning(Context context,String serviceName) &#123; ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningServiceInfo&gt; infos = am.getRunningServices(100); for (ActivityManager.RunningServiceInfo info : infos) &#123; String name = info.service.getClassName(); if (name.equals(serviceName)) &#123; return true; &#125; &#125; return false; &#125;&#125; 在主要的 service 中开启常驻通知栏，并将服务改成前台服务： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MusicService extends Service &#123; private String TAG = MusicService.class.getSimpleName(); private NotificationManager notificationManager; private String notificationId = &quot;serviceid&quot;; private String notificationName = &quot;servicename&quot;; public MusicService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, &quot;onCreate: 启动服务&quot;); notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); //创建NotificationChannel if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)&#123; NotificationChannel channel = new NotificationChannel(notificationId, notificationName, NotificationManager.IMPORTANCE_HIGH); notificationManager.createNotificationChannel(channel); &#125; startForeground(1,getNotification()); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, &quot;onDestroy: 停止服务&quot;); &#125; private Notification getNotification() &#123; Notification.Builder builder = new Notification.Builder(this) .setSmallIcon(R.mipmap.ic_launcher_round) .setContentTitle(&quot;开启定位监听&quot;) .setContentText(&quot;定位中&quot;); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; builder.setChannelId(notificationId); &#125; Notification notification = builder.build(); return notification; &#125;&#125; 启动的时候，同时启动2个 service ： 12startService(new Intent(getApplicationContext(), CoreService.class));startService(new Intent(getApplicationContext(), MusicService.class)); 在 Manifest 文件中进行注册 1234567&lt;service android:name=&quot;.service.MusicService&quot; android:priority=&quot;1000&quot; ndroid:persistent=&quot;true&quot; /&gt;&lt;service android:name=&quot;.service.CoreService&quot; android:persistent=&quot;true&quot; /&gt; 方案三：监听推送通知，拉活service+常驻通知栏 若项目集成了推送，服务端可定时循环发送透传消息(通知栏没有显示的通知消息)，应用接收到透传消息后，判断需要保活的 service 是否存活，若不存活，则拉活： 启动需保活的 service 的同时，开启常驻通知栏并将服务改成前台服务 该方案的具体使用方式与方案二相似，请参考方案二。 方案四：定时唤醒屏幕 以上三种方案可延长市面上常见手机(华为，小米)的保活时间，一些特定的手机或定制的手机可采用定时唤醒屏幕的方式，以延长保活时间： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MusicService extends Service &#123; private String TAG = MusicService.class.getSimpleName(); private ScheduledThreadPoolExecutor mScheduled; public MusicService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, &quot;onCreate: 启动服务&quot;); if (mScheduled == null) &#123; mScheduled = new ScheduledThreadPoolExecutor(1); mScheduled.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; wakeUpAndUnlock(); &#125; &#125;, 0, 2000, TimeUnit.MILLISECONDS); &#125; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return START_STICKY; &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, &quot;onDestroy: 停止服务&quot;); &#125; /** * 唤醒手机屏幕并解锁 */ public void wakeUpAndUnlock() &#123; // 获取电源管理器对象 PowerManager pm = (PowerManager) getApplicationContext().getSystemService(Context.POWER_SERVICE); boolean screenOn = pm.isScreenOn(); if (!screenOn) &#123; // 获取PowerManager.WakeLock对象,后面的参数|表示同时传入两个值,最后的是LogCat里用的Tag @SuppressLint(&quot;InvalidWakeLockTag&quot;) PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_BRIGHT_WAKE_LOCK, &quot;bright&quot;); // 点亮屏幕 wl.acquire(10000); // 释放 wl.release(); &#125; // 屏幕解锁 KeyguardManager keyguardManager = (KeyguardManager) getApplicationContext().getSystemService(KEYGUARD_SERVICE); KeyguardManager.KeyguardLock keyguardLock = keyguardManager.newKeyguardLock(&quot;unLock&quot;); // 屏幕锁定 keyguardLock.reenableKeyguard(); // 解锁 keyguardLock.disableKeyguard(); &#125;&#125; 一些小细节Application 中的设置 persistent：设置为 true，将应用设为系统级应用，可适当的延长保活时间。 largeHeap：设置为 true，扩大设备给 APP 分配的运行内存，延长 APP 被设备清理的时间。 关键的 Service 的设置 persistent：设置为 true，将应用设为系统级服务，可适当的延长保活时间。 priority：设置为1000，提升 service 的优先级，最大为1000. 部分手机的设置Android 8.0及以上的华为手机建议手动开启允许应用在后台运行的设置，具体开启步骤如下： 一些特制的手机，若前三种方案皆无效，方案四也无法唤醒屏幕，可在设置界面搜索屏幕关键字，查看是否有关于屏幕锁定的一些设置。 后台GPS获取位置信息若项目有需求，需要在保活的 service 中频繁的获取 GPS 位置信息，Android8.0及以上需要开启常驻通知栏，位置信息才会频繁发生改变。 项目实战前段时间某项目提出了一个需求，要求上报用户的行动路线也就是要实现轨迹上报的功能，这主要有2个难点：难点一：应用在后台的存活时间要长；难点二：应用要频繁的获取GPS位置信息，并进行数据上报。 采用的保活方案：播放无声的音乐+双service+常驻通知栏目的：1. 播放无声的音乐+双service 主要是延长应用在后台存活时间2. 常驻通知栏 主要是确保应用在后台可以频繁的获取位置信息 一番操作下来，自测华为 Android 9.0 的设备可以满足需求，可是好景不长，现场反馈一台华为 Android 8.0 的设备和一台定制 Android 9.0 的手机，存活时间极短。由于没有对应的设备，只能到现场去查看。 现场测试结果：1. 华为 Android 8.0的手机未按要求开启允许应用在后台运行的设置，打开之后，问题解决；2. 定制的Android 9.0手机，由于是定制手机，市面上没有相关的资料可以查询，联系了手机厂商询问是否留下了白名单入口，无结果，下载了QQ音乐，测试QQ音乐能否存活，存活失败，无奈之下只能测试使用定时唤醒屏幕了，并且此设备需要设置每隔2秒唤醒一次屏幕，多次测试后，最终达到保活的目的，耗电量也能接受，于是针对这种定制手机采用了屏幕定时唤醒的方案解决问题。 疑问解答Q：用了这四种方案是不是能永久存活呢？ 随着 Android 系统版本的越来越高，没有肯定能保活 Android 进程的方案，我们所能做的，只是尽量延长 Android 进程的存活时间。 Q：进程保活的关键是什么呢？ Android 进程保活的关键主要是以下两点: 提升进程的优先级，延缓被杀时间； 发送心跳包，延缓被杀时间。 Q：为什么QQ，微信可以一直存活呢？ 因为用户量大，跟手机厂商合作，进入了手机厂商的白名单。 Q：Android 开发人员该如何选择呢？ 优先使用方案二，若项目集成了推送，方案二和方案三结合使用，若部分手机无效，再加入方案一，最后选择是否集成方案四。 Q：四种方案的优劣和相应的测试结果呢？ 方案名 优点 劣处 Android版本 保活时间 播放无声的音乐 1. 相对稳定 2. 保活时间长 能耗增加，部分华为手机会弹出应用耗电量过大的情况 Android 8.0及以下 24小时及以上 双service+常驻通知栏 耗电极低 不稳定，大部分情况可保活24小时以上，个别情况只能保活2小时内 Android 9.0 24小时及以上 监听推送通知，拉活service+常驻通知栏 1. 相对稳定2. 耗电低 1. 应用需集成消息推送2. 若发送推送太频繁有被封号的风险 Android 9.0 12小时以内 定时唤醒屏幕 1. 相对稳定 2. 保活时间长 1. 耗电极大2. 需根据不同的手机配置相应的唤醒屏幕时间 Android 9.0及以下 24小时及以上]]></content>
      <categories>
        <category>Android</category>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>进程</tag>
        <tag>保活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fragment+webview+横竖屏切换问题排查]]></title>
    <url>%2F2019%2F08%2F27%2Ffragment-webview-%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[问题首现若只想知道如何解决问题，请直接到问题解决。 因文件预览需要横屏显示，并且文件预览采用的是webview加载html的方式，并且webview又封装了一层fragment，所以横竖屏切换的主要问题变成了 fragment+wenview 实现横竖屏切换。 一开始按照网上的大部分说法实现，每次横竖屏切换的时候，不重新启动activity的生命周期，只需要监测 onConfigurationChanged 方法即可。多次测试发现，activity的生命周期没有重新走，但每次都要多次实例化fragment，导致了多次快速横竖屏之后，界面卡顿严重的问题。 此次主要是如何解决fragment为何会多次实例化的问题。 问题排查测试多次百度搜索测试无果，同事提醒，可能跟侧滑关闭的背景有关，于是尝试了将侧滑关闭功能关闭，无效，在侧滑关闭加上白色背景，依然无效，设置全局白色背景，有效了！！！ 这才意识到可能跟background有关，查看了下代码，发现在style里面全局设置了背景为透明，不可能把全局的背景都改成白色，太影响性能了哇。 于是，新写了个style，加了个白色背景，最初采用的方式是，在加载预览界面的activity中，采用Java的方式添加style，测试下来，居然无效，瞬间懵逼了，难道单个添加无效么？不信邪了，这次直接在manifest-activity中添加了style，成功了！！！ 问题解决适用场景： FragmentA 中 加载 WebView，ActivityA 中加载多个 FragmentA，ActivityA 打开 ActivityB，ActivityB 中加载 FragmentA，且 ActivityA 不进行横竖屏切换，ActivityB 支持横竖屏切换。 bug现象： ActivityB 横竖屏切换的时候，页面加载卡顿，且多次实例化 FragmentA。 解决方案： 在 manifest 中找到 ActivityB，并添加 theme，style 中设置 背景色为白色。]]></content>
      <categories>
        <category>Android</category>
        <category>问题排查</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>横竖屏</tag>
        <tag>fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Appium自动化测试]]></title>
    <url>%2F2019%2F08%2F22%2Fappium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[相关链接官网：http://appium.io/ 使用Java编写API文档：http://appium.github.io/java-client/ 学习文档：https://www.cnblogs.com/fnng/p/4540731.html 技术展示安装(仅Windows)若电脑上未安装node.js，请先安装node.js 下载安装包，下载地址为：https://nodejs.org/en/download/ 选择对应的版本，下载后，打开安装，一直下一步即可（可修改安装目录） 安装完成后，检测下path环境变量是否配置了Node.js，打开Windows命令提示符，输入命令”path”，输出如下结果： Android的SDK安装相信Android开发人员都已安装好Android的SDK了，但Android的环境变量你设置了么？我本机的目录为：E:\Android\Sdk。下面设置环境变量：“我的电脑” 右键菜单 —&gt; 属性 —&gt; 高级 —&gt; 环境变量 —&gt; 系统变量 —&gt; 新建： 变量名 变量值 ANDROID_HOME E:\Android\Sdk 找到 path 变量名—&gt; “编辑” 添加： 变量名 变量值 PATH ;%ANDROID_HOME%\platform-tools;%ANDROID_HOME%\tools; 安装 Appium Server可以在Appium官方网站上下载操作系统相应的Appium版本，下载地址：https://bitbucket.org/appium/appium.app/downloads/，若无法下载，也可使用提供的百度网盘下载地址：链接: https://pan.baidu.com/s/1UdbSk02TzUS8BQKzOQFYfw 提取码: zus2 下载的 AppiumForWindows.zip 进行解压，点击 appium-installer.exe 进行安装。 根据提示，一步一步进行安装，这里不再啰嗦。最终在会桌面上生成 Appium图标 , 双击启动，appium server 界面如下： 最后，打开Windows命令提示符，输入“appium-doctor”命令，如果出现以下提示，说明你Appium所需要的各项环境都已准备完成。 注：如果提示：“appium-doctor”不是内部或外部命令，找到Appium的安装目录，例如：E:\Appium\node_modules\.bin添加到环境变量path下面（参考Java环境的设置） Appium-desktopAppium-desktop是什么Appium-Server有一两年没有更新了。Windows版在 2015 年底止步于的 AppiumForWindows_1_4_16_1.zip。 于是，新的工具 Appium-desktop 来了！ 它来继续 Appium-Server的使命，当然， Appium-Server当前仍然是可用的。 注：Appium-Server最高支持模拟器Android版本为6.0，推荐使用 Appium-desktop。 下载与安装下载地址：https://github.com/appium/appium-desktop/releases根据自己的平台选择相关的包进行下载。本文以 Windows 为例，选择 Appium-windows-1.12.1.exe 文件进行下载，下载完成后，双击 exe 文件，等待安装完成即可。 启动运行双击打开桌面上紫色的 appium 图标 点击 “启动服务器 V 1.12.1” 按钮启动服务 现在可以启动移动设备（真机或模拟器），编写Appium自动化测试脚本，可以通过 Appium-desktop 来运行测试。 连接真机测试主要讲解如何连接真机进行测试。 手机通过USB连接电脑，选择传输文件(MTP) 打开开发者选项，允许USB调试，允许USB安装 打开Windows命令提示符，输入”adb devices”，可弹出电脑是否连接真机，获取到真机的devices 注：如果提示：“adb”不是内部或外部命令，找到adb的安装目录，例如：E:\Android\Sdk\platform-tools添加到环境变量path下面（参考Java环境的设置） java-client安装与测试此次主要讲解的是使用 Java 语言编写 appium 自动化测试脚本。 前提条件 安装 Java 环境 安装 IntelliJ IDEA 或 Eclipse (下面讲解的是Eclipse) 安装 Maven Maven 安装 Java-client 启动Eclipse，创建Maven项目 导入 appium 的 Java-client 输入项目名称，id即可下一步 最后，pom.xml中的信息应如下： 注：截止至4月26日为止，最新版本为7.0.0，最新版本号，可在github Java-client开源项目上查看。 开始测试编写第一个Appium测试程序 启动APP12345678910111213141516171819202122232425package com.test;import java.net.MalformedURLException;import java.net.URL;import org.openqa.selenium.remote.DesiredCapabilities;import io.appium.java_client.android.AndroidDriver;public class TestLanuch &#123; private static String path = &quot;E:\\Epoint\\epoint\\component\\FramePlugins\\workplatform\\release\\workplatform-release.apk&quot;; public static void main(String[] args) throws MalformedURLException, InterruptedException &#123; DesiredCapabilities capabilities = new DesiredCapabilities(); capabilities.setCapability(&quot;deviceName&quot;, &quot;8ea41751&quot;); capabilities.setCapability(&quot;automationName&quot;, &quot;uiautomator2&quot;); capabilities.setCapability(&quot;platformName&quot;, &quot;Android&quot;); capabilities.setCapability(&quot;platformVersion&quot;, &quot;8.0.0&quot;); capabilities.setCapability(&quot;autoGrantPermissions&quot;, true); capabilities.setCapability(&quot;app&quot;, path); AndroidDriver driver = new AndroidDriver(new URL(&quot;http://127.0.0.1:4723/wd/hub&quot;), capabilities); driver.quit(); &#125;&#125; deviceName：启动哪种设备，是真机还是模拟器，若是真机，填写”adb devices”获取的设备号 automationName：使用哪种自动化引擎 platformName：使用哪种移动平台 platformVersion：指定平台的系统版本。例如指的Android平台，版本为8.0.0 autoGrantPermissions：是否自动允许权限 app：打包后，apk在本地的路径 appPackage：应用的包名 appActivity：应用启动页 注：若手机上本无此APP，使用参数app，不使用appPackage和appActivity，若手机上有此APP，使用appPackage和appActivity，不使用参数app。 登录APP123456789101112131415161718192021222324252627282930313233343536373839404142public static void testLogin(long time) &#123; if (timer == null) &#123; timer = new Timer(); &#125; timer.schedule(new TimerTask() &#123; @Override public void run() &#123; if (driver.getPageSource().contains(&quot;com.epoint.workplatform:id/iv_cancel&quot;)) &#123; System.out.println(&quot;APP需要更新&quot;); System.out.println(&quot;取消更新&quot;); driver.findElement(By.id(&quot;com.epoint.workplatform:id/iv_cancel&quot;)).click(); if (timer != null) &#123; timer.cancel(); timer = null; &#125; testLogin(2000); &#125; else if (driver.currentActivity().contains(&quot;MainActivity&quot;)) &#123; System.out.println(&quot;用户已登录过&quot;); System.out.println(driver.getPageSource()); &#125; else if (driver.currentActivity().contains(&quot;launcher.Launcher&quot;)) &#123; System.out.println(&quot;返回桌面&quot;); &#125; else if (driver.currentActivity().contains(&quot;GrantPermissionsActivity&quot;)) &#123; System.out.println(&quot;初次登录&quot;); System.out.println(&quot;授予权限&quot;); driver.findElement(By.id(&quot;android:id/button1&quot;)).click(); if (timer != null) &#123; timer.cancel(); timer = null; &#125; testLogin(5000); &#125; else if (driver.currentActivity().contains(&quot;LoginActivity&quot;)) &#123; driver.findElement(By.id(&quot;com.epoint.workplatform:id/et_loginid&quot;)).sendKeys(&quot;dywei&quot;); driver.findElement(By.id(&quot;com.epoint.workplatform:id/et_pwd&quot;)).sendKeys(&quot;11111&quot;); driver.findElement(By.id(&quot;com.epoint.workplatform:id/btn_login&quot;)).click(); System.out.println(&quot;登录成功&quot;); &#125; else &#123; System.out.println(&quot;启动页时间太长&quot;); System.out.println(driver.getPageSource()); &#125; &#125; &#125;, time);&#125; 技术总结测试脚本的编写并不局限于Java，支持多种语言，且可以实现一套测试脚本的编写完成Android端和iOS端的自动化测试，有兴趣的可以研究研究。]]></content>
      <categories>
        <category>Android</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自动化</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android设备通过数据线进行相互通信]]></title>
    <url>%2F2019%2F08%2F19%2FAndroid%E8%AE%BE%E5%A4%87%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E7%BA%BF%E8%BF%9B%E8%A1%8C%E7%9B%B8%E4%BA%92%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[具体步骤发现设备12UsbManager usbManager = (UsbManager) context.getSystemService(Context.USB_SERVICE);Map&lt;String, UsbDevice&gt; usbList = usbManager.getDeviceList(); 官方注释： 12This class represents a USB device attached to the android device with the android device acting as the USB host. 这个类代表了android所连接的usb设备。 打开设备需要打开刚刚搜索到的usb设备。 一般来说，在没有定制的android设备上首次访问usb设备的时候，默认我们是没有访问权限的，因此我们首先要判断对当前要打开的usbDevice是否有访问权限： 123456789if (!usbManager.hasPermission(usbDevice)) &#123; usbPermissionReceiver = new UsbPermissionReceiver(); //申请权限 Intent intent = new Intent(ACTION_DEVICE_PERMISSION); PendingIntent mPermissionIntent = PendingIntent.getBroadcast(context, 0, intent, 0); IntentFilter permissionFilter = new IntentFilter(ACTION_DEVICE_PERMISSION); context.registerReceiver(usbPermissionReceiver, permissionFilter); usbManager.requestPermission(usbDevice, mPermissionIntent);&#125; 需要声明一个广播UsbPermissionReceiver，当接受到授权成功的广播后做一些其他处理。 1234567891011121314151617private class UsbPermissionReceiver extends BroadcastReceiver &#123; public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (ACTION_DEVICE_PERMISSION.equals(action)) &#123; synchronized (this) &#123; UsbDevice device = intent.getParcelableExtra(UsbManager.EXTRA_DEVICE); if (device.getDeviceName().equals(usbDevice.getDeviceName()) &#123; if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) &#123; //授权成功,在这里进行打开设备操作 &#125; else &#123; //授权失败 &#125; &#125; &#125; &#125; &#125;&#125; 接下来，要找到具有数据传输功能的接口UsbInterface，从它里面找到数据输入和输出端口UsbEndpoint，一般情况下，一个usbDevice有多个UsbInterface，我们需要的一般是第一个，所以： 1usbInterface=usbDevice.getInterface(0); 同样的，一个usbInterface有多个UsbEndpoint，有控制端口和数据端口等，因此我们需要根据类型和数据流向来找到需要的数据输入和输出两个端口： 12345678910for (int index = 0; index &lt; usbInterface.getEndpointCount(); index++) &#123; UsbEndpoint point = usbInterface.getEndpoint(index); if (point.getType() == UsbConstants.USB_ENDPOINT_XFER_BULK) &#123; if (point.getDirection() == UsbConstants.USB_DIR_IN) &#123; usbEndpointIn = point; &#125; else if (point.getDirection() == UsbConstants.USB_DIR_OUT) &#123; usbEndpointOut = point; &#125; &#125;&#125; 最后，才是真正的打开usb设备，我们需要和usb外设建立一个UsbDeviceConnection，官方注释： 1This class is used for sending and receiving data and control messages to a USB device. UsbDeviceConnection的获取： 1usbDeviceConnection = usbManager.openDevice(usbDevice); 数据传输 向usb外设发送数据 在第二步中，我们已经获取了数据的输出端口usbEndpointIn，我们向外设发送数据就是通过这个端口来实现的。 1int ret = usbDeviceConnection.bulkTransfer(usbEndpointOut, data, data.length, DEFAULT_TIMEOUT); bulkTransfer这个函数用于在给定的端口进行数据传输，第一个参数就是此次传输的端口，这里我们用的输出端口，第二个参数是要发送的数据，类型为字节数组，第三个参数代表要发送的数据长度，最后一个参数是超时，返回值代表发送成功的字节数，如果返回-1，那就是发送失败了。 接受usb外设发送来的数据 已经找到了数据输入端口usbEndpointIn，因为数据的输入是不定时的，因此我们可以另开一个线程，来专门接受数据。 1234567891011int inMax = inEndpoint.getMaxPacketSize(); ByteBuffer byteBuffer = ByteBuffer.allocate(inMax); UsbRequest usbRequest = new UsbRequest(); usbRequest.initialize(connection, inEndpoint); usbRequest.queue(byteBuffer, inMax); if(connection.requestWait() == usbRequest)&#123; byte[] retData = byteBuffer.array(); for(Byte byte1 : retData)&#123; System.err.println(byte1); &#125; &#125; 注：理论上设备之间的连接已经建立了，也可以首发数据了，但是，我们大部分情况下还需要对usb串口进行一些配置，比如波特率,停止位,数据控制等，不然两边配置不同，收到的数据会乱码，具体怎么配置，需要看串口芯片。 测试设备需求 Android版本&gt;3.2的设备 OTG转接线 项目地址， 请戳我]]></content>
      <categories>
        <category>Android</category>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>通信</tag>
        <tag>USB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI检测]]></title>
    <url>%2F2019%2F08%2F15%2FUI%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[工具推荐UI检测的工具，Hierarchy Viewer和Layout Inspector。 Hierarchy Viewer官方地址 Layout Inspector官方地址 虽然Hierarchy Viewer已经废弃了，但感觉还是有必要介绍一下的。 Hierarchy Viewer工具打开方式AS版本：3.3.2 打开方式： 本地安装SDK目录-&gt;sdk-&gt;tools-&gt;monitor.bat 老版的AS打开方式： 本地安装SDK目录-&gt;sdk-&gt;tools-&gt;hierarchyviewer.bat Android Studio : 工具栏-&gt;Tools-&gt;Android-&gt;Android Device Monitor 在命令行输入 hierarchyviewer 工具的使用设备连接（真机需要手机root权限）成功后左侧Windows小手机会看到设备信息 打开Hierarchy View点击Window-&gt;Open Perspective-&gt;Hierarchy View 若期间出现此问题 选择使用本地IP，并关闭，重新启动即可 此时，应该会看到如下图了： Tree View：显示视图层次结构的树视图。 可以使用鼠标拖动并放大树底部的缩放控件 Tree Overview：为应用程序的完整视图层次结构提供鸟瞰图。 移动灰色矩形以更改树视图中可见的视口。 Layout View：显示布局的线框视图。 当前所选视图的轮廓为红色，其父视图为浅红色。单击此处的视图也会在树视图中选择它，反之亦然。 hierarchy view 视图层次结构是布局的快照，因此不会自动更新。 要更新层次结构视图，点击右上角蓝色金字塔（Reload the view hierarchy）。 要想保存Tree View,点击右上角蓝色金字塔左边小文档,左边是PNG格式,右边是PS的PSD格式。 获取布局的绘制 选择一个节点，点击Profile Mode按钮,可以获取到布局绘制的时间，如图: 绿:表示该View的此项性能比该View Tree中超过50%的View都要快；例如,一个绿点的测量时间意味着这个视图的测量时间快于树中的视图对象的50%。 黄: 表示该View的此项性能比该View Tree中超过50%的View都要慢；例如,一个黄点布局意味着这种观点有较慢的布局时间超过50%的树视图对象。 红: 表示该View的此项性能是View Tree中最慢的；例如,一个红点的绘制时间意味着花费时间最多的这一观点在树上画所有的视图对象。 布局性能分析红色节点是代表应用性能慢的一个潜在问题，下面是几个例子，如何来分析和解释红点的出现原因？ 如果在叶节点或者ViewGroup中，只有极少的子节点，这可能反映出一个问题，应用可能在设备上运行并不慢，但是你需要指导为什么这个节点是红色的，可以借助Systrace或者Traceview工具，获取更多额外的信息； 如果一个视图组里面有许多的子节点，并且测量阶段呈现为红色，则需要观察下子节点的绘制情况； 如果视图层级结构中的根视图，Messure阶段为红色，Layout阶段为红色，Draw阶段为黄色，这个是比较常见的，因为这个节点是所有其它视图的父类； 如果视图结构中的一个叶子节点，有20个视图是红色的Draw阶段，这是有问题的，需要检查代码里面的onDraw方法，不应该在那里调用。 Layout Inspector工具打开方式 在连接的设备或模拟器上运行应用； 点击 Tools &gt; Android &gt; Layout Inspector； 在出现的 Choose Process 对话框中，选择想要检查的应用进程，然后点击 OK 工具的使用布局检查器会捕获快照，将它保存为 .li 文件并打开。如图所示，布局检查器将显示以下内容： View Tree：视图在布局中的层次结构。 Screenshot：带每个视图可视边界的设备屏幕截图。 Properties Table：选定视图的布局属性。 如果布局包括重叠视图，则默认情况下，只有前面的视图可以在屏幕截图中点击。 要让后面的视图可以在屏幕截图中点击，请执行以下操作： 在 View Tree 中右键点击前面的视图，然后取消选中 Show in preview。 此操作不会让视图内容消失；仅会让屏幕截图中的可点击边界消失，以便可以点击在它后面的视图。 如果设备上的布局发生变化，布局检查器不会更新。 必须再次点击 Tools &gt; Android &gt; Layout Inspector，创建一个新的快照。每一个快照都将保存到 project-name/captures/ 内一个单独的 .li 文件中。 结论Hierarchy Viewer虽然已经废弃了，但实际应用中还是不能放弃的，相比较而言，Layout Inspector看布局的层级较为轻松，但Hierarchy Viewer看布局的绘制时间更为轻松，两者相结合，对布局的检测优化更为轻松，所以自我感觉两者都不能放弃。]]></content>
      <categories>
        <category>Android</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
        <tag>性能</tag>
        <tag>检测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI卡顿优化]]></title>
    <url>%2F2019%2F08%2F15%2FUI%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[神奇的16msAndroid 系统每隔 16ms 发出 VSYNC 信号触发对UI进行渲染，那么就要求每一帧都要在 16ms 内绘制完成（包括发送给 GPU 和 CPU 绘制到缓冲区的命令），这样就能够达到流畅的画面所需要的60fps。 如果你的某个操作花费时间是24ms，系统在得到 VSYNC 信号的时候就无法进行正常渲染，这样就发生了丢帧现象。那么用户在 32ms 内看到的会是同一帧画面。 有很多原因可以导致丢帧(卡顿)，这里列举一些常见的： layout 太过复杂，层次过多 UI 上有层叠太多的绘制单元，过度绘制 CPU 或者 GPU 负载过重 动画执行的次数过多 频繁 GC，主要是内存抖动 UI 线程执行耗时操作 等等 layout 太过复杂，层次过多layout 布局是一棵树，树根是 window 的 decorView，套嵌的子 view 越深，树就越复杂，渲染就越费时间。每个 View 都会经过 measure、layout 和 draw 三个流程，都是从树根开始，那么选父布局的时候就要考虑渲染的性能问题：这里分析一下常用的布局控件 LinearLayout 和 RelativeLayout： LinearLayoutLinearLayout 在 measure 的时候，在横向或者纵向会去测量子 View 的宽度或高度，且只会测量一次，但是当设置 layout_weight 属性的时候会去测量两次才能获得精确的展示尺寸。 RelativeLayoutRelativeLayout 在 measure 的时候会在横向和纵向各测量一次。 简析如果带有 weight 属性的 LinearLayout 或者 RelativeLayout 被套嵌使用，measure 所费时间可能会呈指数级增长（两个套嵌的叶子 view 会有四次 measure，三个套嵌的叶子 view 会有8次的 measure）。为了缩短这个时间，保持树形结构尽量扁平（深度低），而且尽量要移除所有不需要渲染的 view。 优化 避免复杂的 View 层级 避免 layout 顶层使用 RelativeLayout 布局层次相同的情况下，使用 LinearLayout 复杂布局建议采用 ConstraintLayout 或 RelativeLayout 而不是多层次的 LinearLayout 标签复用 标签减少嵌套 尽量避免 layout_weight 视图按需加载或者使用 ViewStub 注：不会查看布局层次及时间的请查看上一篇UI检测。 层叠太多，过度绘制跟 measure 一样， View 的绘制也是从树根开始一层一层往叶子绘制，就难免导致叶子的绘制挡住了其父节点的一些绘制的内容。过渡绘制是一个术语，表示某些组件在屏幕上的一个像素点的绘制次数超过 1 次。过度绘制导致的问题是花了太多的时间去绘制那些堆叠在下面的、用户看不到的东西，浪费了 CPU 周期和渲染时间。 如何查看是否过渡绘制 打开手机的开发者选项 找到 调试GPU过度绘制 选择 显示过度绘制区域 此时我们可以看到屏幕上”丰富多彩”了。 蓝色，淡绿，淡红，深红代表了4种不同程度的 Overdraw 情况，我们的目标就是尽量减少红色 Overdraw，看到更多的蓝色甚至白色区域。 如何优化 去除重复或者不必要的 background 点击态中的 normal 尽量设置成 transparent 去除 window 中的 background（这个可以通过处理 decorView 或者设置 Theme 的方式） 若是自定义控件的话，通过 canvas.clipRect() 帮助系统识别那些可见的区域 负载过重UI 线程是应用的主线程，很多的性能和卡顿问题是由于在主线程中做了大量的工作。除了主线程外，子线程占用过多 CPU 资源也会导致渲染性能问题。 在 UI 渲染的过程中，是 CPU 和 GPU 共同合作完成的，其中 CPU 负责把 UI 组件计算成 Polygons，Texture 纹理，然后交给 GPU 进行栅格化渲染。 GPU 呈现模式分析打开方法： 打开手机的开发者选项 找到 GPU呈现模式分析 选择 在屏幕上显示为条形图 此时我们可以看到屏幕的上放或下方多了各种颜色的条形图。 各颜色含义： 个人简析GPU呈现模式主要方便看到连续的界面绘制是否超过16ms，不方便看每个界面详细的绘制时间，推荐使用Hierarchy Viewer查看详细的具体是绘制时间。 内存抖动 主要导致原因是频繁创建大对象或者频繁创建大量对象，并且这些对象属于用完就废弃的，比如 byte[] 。 优化 大对象可以使用对象池复用，比如 byte[] 尽量在 16ms 内少创建对象，比如在 onDraw 中创建 Paint 对象，decode Bitmap 之类的 硬件加速并非所有的都支持硬件加速，其中包括 clipPath() 等；同时也有一些方法在开启硬件加速之后与不开启硬件加速效果不一样，比如 drawBitmapMesh() 等。 Application 级别1&lt;applicationandroid:hardwareAccelerated = &quot;true&quot; ...&gt; Activity 级别1&lt;activity android:hardwareAccelerated = &quot;true&quot; ...&gt; Window 级别123getWindow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); View 级别1View.setLayerType(View.LAYER_TYPE_HARDWARE, null);]]></content>
      <categories>
        <category>Android</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
        <tag>性能</tag>
        <tag>卡顿优化</tag>
      </tags>
  </entry>
</search>
