<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Appium自动化测试]]></title>
    <url>%2F2019%2F08%2F22%2Fappium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[相关链接官网：http://appium.io/ 使用Java编写API文档：http://appium.github.io/java-client/ 学习文档：https://www.cnblogs.com/fnng/p/4540731.html 技术展示安装(仅Windows)若电脑上未安装node.js，请先安装node.js 下载安装包，下载地址为：https://nodejs.org/en/download/ 选择对应的版本，下载后，打开安装，一直下一步即可（可修改安装目录） 安装完成后，检测下path环境变量是否配置了Node.js，打开Windows命令提示符，输入命令”path”，输出如下结果： Android的SDK安装相信Android开发人员都已安装好Android的SDK了，但Android的环境变量你设置了么？我本机的目录为：E:\Android\Sdk。下面设置环境变量：“我的电脑” 右键菜单 —&gt; 属性 —&gt; 高级 —&gt; 环境变量 —&gt; 系统变量 —&gt; 新建： 变量名 变量值 ANDROID_HOME E:\Android\Sdk 找到 path 变量名—&gt; “编辑” 添加： 变量名 变量值 PATH ;%ANDROID_HOME%\platform-tools;%ANDROID_HOME%\tools; 安装 Appium Server可以在Appium官方网站上下载操作系统相应的Appium版本，下载地址：https://bitbucket.org/appium/appium.app/downloads/，若无法下载，也可使用提供的百度网盘下载地址：链接: https://pan.baidu.com/s/1UdbSk02TzUS8BQKzOQFYfw 提取码: zus2 下载的 AppiumForWindows.zip 进行解压，点击 appium-installer.exe 进行安装。 根据提示，一步一步进行安装，这里不再啰嗦。最终在会桌面上生成 Appium图标 , 双击启动，appium server 界面如下： 最后，打开Windows命令提示符，输入“appium-doctor”命令，如果出现以下提示，说明你Appium所需要的各项环境都已准备完成。 注：如果提示：“appium-doctor”不是内部或外部命令，找到Appium的安装目录，例如：E:\Appium\node_modules\.bin添加到环境变量path下面（参考Java环境的设置） Appium-desktopAppium-desktop是什么Appium-Server有一两年没有更新了。Windows版在 2015 年底止步于的 AppiumForWindows_1_4_16_1.zip。 于是，新的工具 Appium-desktop 来了！ 它来继续 Appium-Server的使命，当然， Appium-Server当前仍然是可用的。 注：Appium-Server最高支持模拟器Android版本为6.0，推荐使用 Appium-desktop。 下载与安装下载地址：https://github.com/appium/appium-desktop/releases根据自己的平台选择相关的包进行下载。本文以 Windows 为例，选择 Appium-windows-1.12.1.exe 文件进行下载，下载完成后，双击 exe 文件，等待安装完成即可。 启动运行双击打开桌面上紫色的 appium 图标 点击 “启动服务器 V 1.12.1” 按钮启动服务 现在可以启动移动设备（真机或模拟器），编写Appium自动化测试脚本，可以通过 Appium-desktop 来运行测试。 连接真机测试主要讲解如何连接真机进行测试。 手机通过USB连接电脑，选择传输文件(MTP) 打开开发者选项，允许USB调试，允许USB安装 打开Windows命令提示符，输入”adb devices”，可弹出电脑是否连接真机，获取到真机的devices 注：如果提示：“adb”不是内部或外部命令，找到adb的安装目录，例如：E:\Android\Sdk\platform-tools添加到环境变量path下面（参考Java环境的设置） java-client安装与测试此次主要讲解的是使用 Java 语言编写 appium 自动化测试脚本。 前提条件 安装 Java 环境 安装 IntelliJ IDEA 或 Eclipse (下面讲解的是Eclipse) 安装 Maven Maven 安装 Java-client 启动Eclipse，创建Maven项目 导入 appium 的 Java-client 输入项目名称，id即可下一步 最后，pom.xml中的信息应如下： 注：截止至4月26日为止，最新版本为7.0.0，最新版本号，可在github Java-client开源项目上查看。 开始测试编写第一个Appium测试程序 启动APP12345678910111213141516171819202122232425package com.test;import java.net.MalformedURLException;import java.net.URL;import org.openqa.selenium.remote.DesiredCapabilities;import io.appium.java_client.android.AndroidDriver;public class TestLanuch &#123; private static String path = &quot;E:\\Epoint\\epoint\\component\\FramePlugins\\workplatform\\release\\workplatform-release.apk&quot;; public static void main(String[] args) throws MalformedURLException, InterruptedException &#123; DesiredCapabilities capabilities = new DesiredCapabilities(); capabilities.setCapability(&quot;deviceName&quot;, &quot;8ea41751&quot;); capabilities.setCapability(&quot;automationName&quot;, &quot;uiautomator2&quot;); capabilities.setCapability(&quot;platformName&quot;, &quot;Android&quot;); capabilities.setCapability(&quot;platformVersion&quot;, &quot;8.0.0&quot;); capabilities.setCapability(&quot;autoGrantPermissions&quot;, true); capabilities.setCapability(&quot;app&quot;, path); AndroidDriver driver = new AndroidDriver(new URL(&quot;http://127.0.0.1:4723/wd/hub&quot;), capabilities); driver.quit(); &#125;&#125; deviceName：启动哪种设备，是真机还是模拟器，若是真机，填写”adb devices”获取的设备号 automationName：使用哪种自动化引擎 platformName：使用哪种移动平台 platformVersion：指定平台的系统版本。例如指的Android平台，版本为8.0.0 autoGrantPermissions：是否自动允许权限 app：打包后，apk在本地的路径 appPackage：应用的包名 appActivity：应用启动页 注：若手机上本无此APP，使用参数app，不使用appPackage和appActivity，若手机上有此APP，使用appPackage和appActivity，不使用参数app。 登录APP123456789101112131415161718192021222324252627282930313233343536373839404142public static void testLogin(long time) &#123; if (timer == null) &#123; timer = new Timer(); &#125; timer.schedule(new TimerTask() &#123; @Override public void run() &#123; if (driver.getPageSource().contains(&quot;com.epoint.workplatform:id/iv_cancel&quot;)) &#123; System.out.println(&quot;APP需要更新&quot;); System.out.println(&quot;取消更新&quot;); driver.findElement(By.id(&quot;com.epoint.workplatform:id/iv_cancel&quot;)).click(); if (timer != null) &#123; timer.cancel(); timer = null; &#125; testLogin(2000); &#125; else if (driver.currentActivity().contains(&quot;MainActivity&quot;)) &#123; System.out.println(&quot;用户已登录过&quot;); System.out.println(driver.getPageSource()); &#125; else if (driver.currentActivity().contains(&quot;launcher.Launcher&quot;)) &#123; System.out.println(&quot;返回桌面&quot;); &#125; else if (driver.currentActivity().contains(&quot;GrantPermissionsActivity&quot;)) &#123; System.out.println(&quot;初次登录&quot;); System.out.println(&quot;授予权限&quot;); driver.findElement(By.id(&quot;android:id/button1&quot;)).click(); if (timer != null) &#123; timer.cancel(); timer = null; &#125; testLogin(5000); &#125; else if (driver.currentActivity().contains(&quot;LoginActivity&quot;)) &#123; driver.findElement(By.id(&quot;com.epoint.workplatform:id/et_loginid&quot;)).sendKeys(&quot;dywei&quot;); driver.findElement(By.id(&quot;com.epoint.workplatform:id/et_pwd&quot;)).sendKeys(&quot;11111&quot;); driver.findElement(By.id(&quot;com.epoint.workplatform:id/btn_login&quot;)).click(); System.out.println(&quot;登录成功&quot;); &#125; else &#123; System.out.println(&quot;启动页时间太长&quot;); System.out.println(driver.getPageSource()); &#125; &#125; &#125;, time);&#125; 技术总结测试脚本的编写并不局限于Java，支持多种语言，且可以实现一套测试脚本的编写完成Android端和iOS端的自动化测试，有兴趣的可以研究研究。]]></content>
      <categories>
        <category>Android</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自动化</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android设备通过数据线进行相互通信]]></title>
    <url>%2F2019%2F08%2F19%2FAndroid%E8%AE%BE%E5%A4%87%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E7%BA%BF%E8%BF%9B%E8%A1%8C%E7%9B%B8%E4%BA%92%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[具体步骤发现设备12UsbManager usbManager = (UsbManager) context.getSystemService(Context.USB_SERVICE);Map&lt;String, UsbDevice&gt; usbList = usbManager.getDeviceList(); 官方注释： 12This class represents a USB device attached to the android device with the android device acting as the USB host. 这个类代表了android所连接的usb设备。 打开设备需要打开刚刚搜索到的usb设备。 一般来说，在没有定制的android设备上首次访问usb设备的时候，默认我们是没有访问权限的，因此我们首先要判断对当前要打开的usbDevice是否有访问权限： 123456789if (!usbManager.hasPermission(usbDevice)) &#123; usbPermissionReceiver = new UsbPermissionReceiver(); //申请权限 Intent intent = new Intent(ACTION_DEVICE_PERMISSION); PendingIntent mPermissionIntent = PendingIntent.getBroadcast(context, 0, intent, 0); IntentFilter permissionFilter = new IntentFilter(ACTION_DEVICE_PERMISSION); context.registerReceiver(usbPermissionReceiver, permissionFilter); usbManager.requestPermission(usbDevice, mPermissionIntent);&#125; 需要声明一个广播UsbPermissionReceiver，当接受到授权成功的广播后做一些其他处理。 1234567891011121314151617private class UsbPermissionReceiver extends BroadcastReceiver &#123; public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (ACTION_DEVICE_PERMISSION.equals(action)) &#123; synchronized (this) &#123; UsbDevice device = intent.getParcelableExtra(UsbManager.EXTRA_DEVICE); if (device.getDeviceName().equals(usbDevice.getDeviceName()) &#123; if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) &#123; //授权成功,在这里进行打开设备操作 &#125; else &#123; //授权失败 &#125; &#125; &#125; &#125; &#125;&#125; 接下来，要找到具有数据传输功能的接口UsbInterface，从它里面找到数据输入和输出端口UsbEndpoint，一般情况下，一个usbDevice有多个UsbInterface，我们需要的一般是第一个，所以： 1usbInterface=usbDevice.getInterface(0); 同样的，一个usbInterface有多个UsbEndpoint，有控制端口和数据端口等，因此我们需要根据类型和数据流向来找到需要的数据输入和输出两个端口： 12345678910for (int index = 0; index &lt; usbInterface.getEndpointCount(); index++) &#123; UsbEndpoint point = usbInterface.getEndpoint(index); if (point.getType() == UsbConstants.USB_ENDPOINT_XFER_BULK) &#123; if (point.getDirection() == UsbConstants.USB_DIR_IN) &#123; usbEndpointIn = point; &#125; else if (point.getDirection() == UsbConstants.USB_DIR_OUT) &#123; usbEndpointOut = point; &#125; &#125;&#125; 最后，才是真正的打开usb设备，我们需要和usb外设建立一个UsbDeviceConnection，官方注释： 1This class is used for sending and receiving data and control messages to a USB device. UsbDeviceConnection的获取： 1usbDeviceConnection = usbManager.openDevice(usbDevice); 数据传输 向usb外设发送数据 在第二步中，我们已经获取了数据的输出端口usbEndpointIn，我们向外设发送数据就是通过这个端口来实现的。 1int ret = usbDeviceConnection.bulkTransfer(usbEndpointOut, data, data.length, DEFAULT_TIMEOUT); bulkTransfer这个函数用于在给定的端口进行数据传输，第一个参数就是此次传输的端口，这里我们用的输出端口，第二个参数是要发送的数据，类型为字节数组，第三个参数代表要发送的数据长度，最后一个参数是超时，返回值代表发送成功的字节数，如果返回-1，那就是发送失败了。 接受usb外设发送来的数据 已经找到了数据输入端口usbEndpointIn，因为数据的输入是不定时的，因此我们可以另开一个线程，来专门接受数据。 1234567891011int inMax = inEndpoint.getMaxPacketSize(); ByteBuffer byteBuffer = ByteBuffer.allocate(inMax); UsbRequest usbRequest = new UsbRequest(); usbRequest.initialize(connection, inEndpoint); usbRequest.queue(byteBuffer, inMax); if(connection.requestWait() == usbRequest)&#123; byte[] retData = byteBuffer.array(); for(Byte byte1 : retData)&#123; System.err.println(byte1); &#125; &#125; 注：理论上设备之间的连接已经建立了，也可以首发数据了，但是，我们大部分情况下还需要对usb串口进行一些配置，比如波特率,停止位,数据控制等，不然两边配置不同，收到的数据会乱码，具体怎么配置，需要看串口芯片。 测试设备需求 Android版本&gt;3.2的设备 OTG转接线 项目地址， 请戳我]]></content>
      <categories>
        <category>Android</category>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>通信</tag>
        <tag>USB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI检测]]></title>
    <url>%2F2019%2F08%2F15%2FUI%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[工具推荐UI检测的工具，Hierarchy Viewer和Layout Inspector。 Hierarchy Viewer官方地址 Layout Inspector官方地址 虽然Hierarchy Viewer已经废弃了，但感觉还是有必要介绍一下的。 Hierarchy Viewer工具打开方式AS版本：3.3.2 打开方式： 本地安装SDK目录-&gt;sdk-&gt;tools-&gt;monitor.bat 老版的AS打开方式： 本地安装SDK目录-&gt;sdk-&gt;tools-&gt;hierarchyviewer.bat Android Studio : 工具栏-&gt;Tools-&gt;Android-&gt;Android Device Monitor 在命令行输入 hierarchyviewer 工具的使用设备连接（真机需要手机root权限）成功后左侧Windows小手机会看到设备信息 打开Hierarchy View点击Window-&gt;Open Perspective-&gt;Hierarchy View 若期间出现此问题 选择使用本地IP，并关闭，重新启动即可 此时，应该会看到如下图了： Tree View：显示视图层次结构的树视图。 可以使用鼠标拖动并放大树底部的缩放控件 Tree Overview：为应用程序的完整视图层次结构提供鸟瞰图。 移动灰色矩形以更改树视图中可见的视口。 Layout View：显示布局的线框视图。 当前所选视图的轮廓为红色，其父视图为浅红色。单击此处的视图也会在树视图中选择它，反之亦然。 hierarchy view 视图层次结构是布局的快照，因此不会自动更新。 要更新层次结构视图，点击右上角蓝色金字塔（Reload the view hierarchy）。 要想保存Tree View,点击右上角蓝色金字塔左边小文档,左边是PNG格式,右边是PS的PSD格式。 获取布局的绘制 选择一个节点，点击Profile Mode按钮,可以获取到布局绘制的时间，如图: 绿:表示该View的此项性能比该View Tree中超过50%的View都要快；例如,一个绿点的测量时间意味着这个视图的测量时间快于树中的视图对象的50%。 黄: 表示该View的此项性能比该View Tree中超过50%的View都要慢；例如,一个黄点布局意味着这种观点有较慢的布局时间超过50%的树视图对象。 红: 表示该View的此项性能是View Tree中最慢的；例如,一个红点的绘制时间意味着花费时间最多的这一观点在树上画所有的视图对象。 布局性能分析红色节点是代表应用性能慢的一个潜在问题，下面是几个例子，如何来分析和解释红点的出现原因？ 如果在叶节点或者ViewGroup中，只有极少的子节点，这可能反映出一个问题，应用可能在设备上运行并不慢，但是你需要指导为什么这个节点是红色的，可以借助Systrace或者Traceview工具，获取更多额外的信息； 如果一个视图组里面有许多的子节点，并且测量阶段呈现为红色，则需要观察下子节点的绘制情况； 如果视图层级结构中的根视图，Messure阶段为红色，Layout阶段为红色，Draw阶段为黄色，这个是比较常见的，因为这个节点是所有其它视图的父类； 如果视图结构中的一个叶子节点，有20个视图是红色的Draw阶段，这是有问题的，需要检查代码里面的onDraw方法，不应该在那里调用。 Layout Inspector工具打开方式 在连接的设备或模拟器上运行应用； 点击 Tools &gt; Android &gt; Layout Inspector； 在出现的 Choose Process 对话框中，选择想要检查的应用进程，然后点击 OK 工具的使用布局检查器会捕获快照，将它保存为 .li 文件并打开。如图所示，布局检查器将显示以下内容： View Tree：视图在布局中的层次结构。 Screenshot：带每个视图可视边界的设备屏幕截图。 Properties Table：选定视图的布局属性。 如果布局包括重叠视图，则默认情况下，只有前面的视图可以在屏幕截图中点击。 要让后面的视图可以在屏幕截图中点击，请执行以下操作： 在 View Tree 中右键点击前面的视图，然后取消选中 Show in preview。 此操作不会让视图内容消失；仅会让屏幕截图中的可点击边界消失，以便可以点击在它后面的视图。 如果设备上的布局发生变化，布局检查器不会更新。 必须再次点击 Tools &gt; Android &gt; Layout Inspector，创建一个新的快照。每一个快照都将保存到 project-name/captures/ 内一个单独的 .li 文件中。 结论Hierarchy Viewer虽然已经废弃了，但实际应用中还是不能放弃的，相比较而言，Layout Inspector看布局的层级较为轻松，但Hierarchy Viewer看布局的绘制时间更为轻松，两者相结合，对布局的检测优化更为轻松，所以自我感觉两者都不能放弃。]]></content>
      <categories>
        <category>Android</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
        <tag>性能</tag>
        <tag>检测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI卡顿优化]]></title>
    <url>%2F2019%2F08%2F15%2FUI%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[神奇的16msAndroid 系统每隔 16ms 发出 VSYNC 信号触发对UI进行渲染，那么就要求每一帧都要在 16ms 内绘制完成（包括发送给 GPU 和 CPU 绘制到缓冲区的命令），这样就能够达到流畅的画面所需要的60fps。 如果你的某个操作花费时间是24ms，系统在得到 VSYNC 信号的时候就无法进行正常渲染，这样就发生了丢帧现象。那么用户在 32ms 内看到的会是同一帧画面。 有很多原因可以导致丢帧(卡顿)，这里列举一些常见的： layout 太过复杂，层次过多 UI 上有层叠太多的绘制单元，过度绘制 CPU 或者 GPU 负载过重 动画执行的次数过多 频繁 GC，主要是内存抖动 UI 线程执行耗时操作 等等 layout 太过复杂，层次过多layout 布局是一棵树，树根是 window 的 decorView，套嵌的子 view 越深，树就越复杂，渲染就越费时间。每个 View 都会经过 measure、layout 和 draw 三个流程，都是从树根开始，那么选父布局的时候就要考虑渲染的性能问题：这里分析一下常用的布局控件 LinearLayout 和 RelativeLayout： LinearLayoutLinearLayout 在 measure 的时候，在横向或者纵向会去测量子 View 的宽度或高度，且只会测量一次，但是当设置 layout_weight 属性的时候会去测量两次才能获得精确的展示尺寸。 RelativeLayoutRelativeLayout 在 measure 的时候会在横向和纵向各测量一次。 简析如果带有 weight 属性的 LinearLayout 或者 RelativeLayout 被套嵌使用，measure 所费时间可能会呈指数级增长（两个套嵌的叶子 view 会有四次 measure，三个套嵌的叶子 view 会有8次的 measure）。为了缩短这个时间，保持树形结构尽量扁平（深度低），而且尽量要移除所有不需要渲染的 view。 优化 避免复杂的 View 层级 避免 layout 顶层使用 RelativeLayout 布局层次相同的情况下，使用 LinearLayout 复杂布局建议采用 ConstraintLayout 或 RelativeLayout 而不是多层次的 LinearLayout 标签复用 标签减少嵌套 尽量避免 layout_weight 视图按需加载或者使用 ViewStub 注：不会查看布局层次及时间的请查看上一篇UI检测。 层叠太多，过度绘制跟 measure 一样， View 的绘制也是从树根开始一层一层往叶子绘制，就难免导致叶子的绘制挡住了其父节点的一些绘制的内容。过渡绘制是一个术语，表示某些组件在屏幕上的一个像素点的绘制次数超过 1 次。过度绘制导致的问题是花了太多的时间去绘制那些堆叠在下面的、用户看不到的东西，浪费了 CPU 周期和渲染时间。 如何查看是否过渡绘制 打开手机的开发者选项 找到 调试GPU过度绘制 选择 显示过度绘制区域 此时我们可以看到屏幕上”丰富多彩”了。 蓝色，淡绿，淡红，深红代表了4种不同程度的 Overdraw 情况，我们的目标就是尽量减少红色 Overdraw，看到更多的蓝色甚至白色区域。 如何优化 去除重复或者不必要的 background 点击态中的 normal 尽量设置成 transparent 去除 window 中的 background（这个可以通过处理 decorView 或者设置 Theme 的方式） 若是自定义控件的话，通过 canvas.clipRect() 帮助系统识别那些可见的区域 负载过重UI 线程是应用的主线程，很多的性能和卡顿问题是由于在主线程中做了大量的工作。除了主线程外，子线程占用过多 CPU 资源也会导致渲染性能问题。 在 UI 渲染的过程中，是 CPU 和 GPU 共同合作完成的，其中 CPU 负责把 UI 组件计算成 Polygons，Texture 纹理，然后交给 GPU 进行栅格化渲染。 GPU 呈现模式分析打开方法： 打开手机的开发者选项 找到 GPU呈现模式分析 选择 在屏幕上显示为条形图 此时我们可以看到屏幕的上放或下方多了各种颜色的条形图。 各颜色含义： 个人简析GPU呈现模式主要方便看到连续的界面绘制是否超过16ms，不方便看每个界面详细的绘制时间，推荐使用Hierarchy Viewer查看详细的具体是绘制时间。 内存抖动 主要导致原因是频繁创建大对象或者频繁创建大量对象，并且这些对象属于用完就废弃的，比如 byte[] 。 优化 大对象可以使用对象池复用，比如 byte[] 尽量在 16ms 内少创建对象，比如在 onDraw 中创建 Paint 对象，decode Bitmap 之类的 硬件加速并非所有的都支持硬件加速，其中包括 clipPath() 等；同时也有一些方法在开启硬件加速之后与不开启硬件加速效果不一样，比如 drawBitmapMesh() 等。 Application 级别1&lt;applicationandroid:hardwareAccelerated = &quot;true&quot; ...&gt; Activity 级别1&lt;activity android:hardwareAccelerated = &quot;true&quot; ...&gt; Window 级别123getWindow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); View 级别1View.setLayerType(View.LAYER_TYPE_HARDWARE, null);]]></content>
      <categories>
        <category>Android</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
        <tag>性能</tag>
        <tag>卡顿优化</tag>
      </tags>
  </entry>
</search>
